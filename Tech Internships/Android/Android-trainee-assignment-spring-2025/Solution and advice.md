# Стажировки для Android-разработчиков в Авито: на что мы смотрим при проверке работ

Наши эксперты проанализировали работы кандидатов. Рассказываем о моментах, на которые стоит обратить особое внимание в своих проектах. Вот такая подсказка на будущее!

## Оформление README

Проверяющему будет проще погрузиться в проект, если вы подробно оформите README и добавите примеры: скрины приложения, а лучше — запись экрана. Так он сможет понять, что приложение работает правильно, и у него есть все нужные функции.

Ещё хорошая практика — указать версию и название эмулятора или тестового девайса, на котором вы запускали приложение.

## Обработка ошибок

Учитывайте все возможные ошибки: без механизма их обработки приложение может упасть, и пользователь не будет понимать, что происходит.

## Использование нейросетей

Если в подготовке проекта вы пользуетесь ChatGPT, это не удастся скрыть от проверяющего. Сама по себе помощь нейросетей не будет минусом при отборе — но злоупотребление нейросетями лишает работу индивидуальности и мешает оценить навыки кандидата. А иногда и вовсе делает проверку невозможной.

## Навигация

Для навигации по приложению рекомендуем использовать `androidx.navigation`.

### Какие у этого плюсы

- Navigation использует файл (`nav_graph.xml`), где маршруты, фрагменты и переходы (actions) задаются декларативно. Это делает логику навигации централизованной, упрощает поддержку кода и внесение в него изменений.
- У Navigation есть встроенные механизмы для работы с deeplink. Можно легко перенаправить пользователя на конкретный экран через URI или интенты.
- Удобно разделять графы навигации на модули, особенно в многомодульных проектах. Индивидуальный `nav_graph` может быть в каждом модуле, оставаясь независимым от других.

## Многомодульность

Многомодульная архитектура — стандартный подход в Android-разработке: она позволяет создавать приложения, которые легко поддерживать и масштабировать. А ещё — упрощает разделение зон ответственности между командами: разработчики могут обособленно работать над своими модулями, не влияя на другие участки кода.

Для многомодульных проектов удобно использовать Gradle: система собирает только модули, которые были изменены. Это уменьшает время сборки, особенно для больших проектов.

### Как работать с разными модулями

#### feature-модули

Важно, чтобы они не зависели друг от друга. Поддерживайте низкую связность, даже когда модули работают вместе и часто обмениваются информацией. Иногда прямая связь нежелательна из-за ограничений архитектуры или циклических зависимостей.

#### common-модули (core)

В них содержится код, который используют другие модули: с ними код становится лаконичнее. Примеры таких модулей — мапперы, навигация, аналитика. Они не представляют конкретный уровень в архитектуре приложения.

### Минимизация публичного API

Важно, чтобы публичный интерфейс модуля был лаконичным и отображал только самое необходимое — без деталей реализации.

Используйте модификаторы `private` или `internal`: так вы уменьшите области видимости и сделаете методы или свойства приватными.

При объявлении зависимостей отдавайте предпочтение подключению через `implementation`, а не `API`. Это поможет сократить время сборки: уменьшится количество модулей, которые нужно пересобрать после изменений.

## Clean Architecture

Если соблюдать принципы Clean Architecture, код станет проще для понимания и сопровождения. А ещё не будет проблем с зависимостями, и приложение разделится на логические блоки.

## MVI-архитектура

При решении тестового задания многие кандидаты использовали архитектуру MVVM. Мы в Авито используем другой подход — MVI.

### Особенности работы с MVI

- Единое управление состоянием: у каждого экрана одно состояние, что упрощает отладку.
- Тестируемость: можно легко писать юнит-тесты для ViewModel, Reducer и State.
- Прогнозируемость: состояние меняется только через Intent — так проще следить за изменениями.

### Принципы работы с MVI

- Используйте DI в модулях проекта.
- Передавайте зависимости через конструктор, а не создавайте внутри классов.
- Описывайте зависимости как интерфейсы, реализации скрывайте и связывайте в конфигурации DI.
- Задавайте время жизни:
  - Общее — уровень приложения
  - Экранное — Activity/Fragment
  - Логика — уровень ViewModel
- Не подтягивайте Android-зависимости в доменный слой — например, `Context`.
- Для тестов и разных окружений подменяйте реализации через DI без изменений в бизнес-коде.
