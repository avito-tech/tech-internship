# Стажировки для Backend-разработчиков в Авито: на что мы смотрим при проверке работ — первая часть

Наши эксперты отсмотрели много тестовых заданий кандидатов — и теперь делятся распространёнными ошибками, чтобы вы могли учесть их в будущем.

## 1. Code style и структура кода

### 1.1. Сортировка импорта
В некоторых проектах отсутствовал единый автоформат, были перемешаны импорты, а отступы и переносы строк — не согласованы.

**Почему так не стоит делать**  
В таком случае падает читаемость кода и скорость код-ревью. Растёт вероятность случайных конфликтов и мелких ошибок при правках.

**Как правильно**  
Стоит включить автоформат и линтер.

---

### 1.2. Разделение обработчиков (handlers)
В работах многих кандидатов обработчики были собраны в одном файле. В `handlers.go` лежали все эндпоинты — `/api/auth`, `/api/info` — без логического разделения по доменам.

**Почему так не стоит делать**  
В такой ситуации файл разрастается, усложняется навигация, растёт риск конфликтов и утечек ответственности между обработчиками.

**Как правильно**  
Стоит разложить эндпоинты по ресурсам или доменам.

**Хороший пример:**
```bash
/internal/http/handlers/
  auth.go       // /api/auth
  coins.go      // /api/sendCoin
  ...
```

---

### 1.3. Моки и код в проде
Часто моки лежат там же, где основной код.

**Почему так не стоит делать**  
В таком случае в навигации появляется шум, растёт риск того, что в проде случайно используется мок, а зависимости пересекутся.

**Как правильно**  
Хранить моки стоит в `mocks/`, а генерировать — через `mockery`. Больше деталей ищите в документации.

---

### 1.4. Названия структур внутри функций
Иногда в функциях создаются «сырые» `struct{...}` вместо именованных типов.

**Почему так не стоит делать**  
Не получается переиспользовать типы, трудно проводить валидацию и тестирование.

**Как правильно**
Стоит ввести именованные DTO или domain-модели.

**Плохой пример**
```go
req := struct{ Name string }{Name: "John"}
```

**Хороший пример**
```go
type User struct {
  Name string
}
```

---

## 2. Архитектура и разделение слоёв

### 2.1. Бизнес-логика и слои
В некоторых проектах HTTP-слой содержал бизнес-логику и выполнял операции с базами данных.

**Почему так не стоит делать**  
В такой ситуации код трудно тестировать, повторно использовать и менять логику без изменений в HTTP-handlers.

**Как правильно**  
Стоит оставлять валидацию входных данных на уровне `handlers`, а бизнес-логику реализовывать в `usecase` — то есть придерживаться чистой архитектуры.

**Хороший пример:**
```go
// Handler: только парсинг и маппинг.
func (h *Handler) SendCoin(w http.ResponseWriter, r *http.Request) {
    var in SendCoinInput
    ctx := r.Context()

    if err := json.NewDecoder(r.Body).Decode(&in); err != nil {
        http.Error(w, "bad request", 400)
        return
    }

    if err := h.usecase.SendCoin(ctx, in.From, in.To, in.Amount); err != nil {
        http.Error(w, err.Error(), 500)
        return
    }
}
```

---

### 2.2. Зависимость билдера
Часто бывает так, что билдер импортирует реализацию, а не интерфейс.

**Почему так не стоит делать**  
Появляется жёсткая связность. В таком случае не получится мокать зависимость в тестах и менять реализацию.

**Как правильно**  
Стоит объявлять интерфейсы на стороне потребителя и создавать зависимость от интерфейса.

**Хороший пример:**
```bash
/internal/repo/merch/
  merch.go                // Реализация репозитория merch.
/internal/service/merch/
  merch.go                // Реализация сервиса merch.
```

```go
// /internal/service/merch/merch.go
package merch

type MerchRepo interface {
    Get(ctx context.Context, name string) error
}

type MerchService struct {
    Repo MerchRepo
}
```

---

### 2.3. Миграции
Иногда кандидаты пишут миграции баз данных полностью в `init.sql`.

**Почему так не стоит делать**  
Становится сложно откатывать или перекатывать миграции частями, теряется история изменений.

**Как правильно**  
Стоит создавать отдельные миграции, а для управления ими использовать специальный инструмент — например, golang-migrate.

**Хороший пример:**
```bash
/migrations/
  0001_init.sql
  0002_add_merch.sql
```

---

## 3. Тесты

### 3.1. Юнит-тесты и e2e
Проверяйте, что код покрыт тестами и они не падают, не появляются flaky тесты.

**Как правильно**  
Стоит добиваться зелёных тестов и исправлять причины flaky тестов. Например, они могут появляться при проверке равенства map — порядок ключей всегда разный.

---

### 3.2. Отдельное тестовое окружение
Следите за тем, чтобы тесты не использовали ту же базу данных, что и приложение. Иначе данные сломаются, и тесты станут нестабильными.

**Как правильно**  
Стоит поднимать отдельную тестовую базу данных. А e2e-тесты лучше выделить в отдельный `docker-compose.e2e.yaml` со своими базами данных, переменными и сетью.

**Хороший пример:**
```yaml
# docker-compose.e2e.yaml
services:
  db_e2e:
    image: postgres:15
    environment:
      POSTGRES_DB: database
      POSTGRES_PASSWORD: password
  api_e2e:
    build: .
    env_file: .env.e2e
    depends_on: [db_e2e]
  tests:
    build: ./e2e_tests
    depends_on: [api_e2e]
```

---

## 4. DevOps и окружение

### 4.1. Работа `docker compose up`
В некоторых проектах сервис не поднимается без ручных правок, в CI не запускается окружение.

**Как правильно**  
Стоит регулярно проверять чистый старт, добавлять healthchecks и зависимости, прописывать entrypoint для миграций.

---

### 4.2. Совпадение версий Go в `go.mod` и Dockerfile
Бывает, в `go.mod` указана одна версия Go, а образ сборки в Dockerfile — другой. В таком случае сборка падает.

**Как правильно**  
Стоит синхронизировать версии и использовать multi-stage build.

**Хороший пример:**
```dockerfile
FROM golang:1.22

WORKDIR ${GOPATH}/avito-shop/
COPY . ${GOPATH}/avito-shop/

RUN go build -o /build ./internal/cmd     && go clean -cache -modcache

EXPOSE 8080
CMD ["/build"]
```

---

### 4.3. Заголовки для JWT
Иногда кандидаты кладут токен в произвольный заголовок вместо `Authorization: Bearer <token>`. Это приводит к несовместимости с библиотеками и путанице в клиентах и тестах.

**Как правильно**  
Стоит придерживаться стандартных заголовков.

**Плохой пример:**
```http
GET /api/info HTTP/1.1
Host: localhost:8080
X-Auth: eyJhbGciOiJIUzI1NiIsInR5cCI6...
```

**Хороший пример:**
```http
GET /api/info HTTP/1.1
Host: localhost:8080
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6...
```

```go
// Чтение токена.
auth := r.Header.Get("Authorization")

const prefix = "Bearer "

if !strings.HasPrefix(auth, prefix) {
  http.Error(w, "unauthorized", http.StatusUnauthorized)
  return
}

token := strings.TrimPrefix(auth, prefix)
// Далее валидация token...
```

---

## 5. Безопасность

### 5.1. Коммиты `.env` в репозиторий
Ошибка, которая встречается очень часто: секреты — к примеру, JWT-ключ или пароли — лежат в репозитории. Это может приводить к серьёзным утечкам данных.

**Как правильно**  
Стоит добавлять `.env` в `.gitignore`, хранить только `.env.example`. Также важно использовать переменные окружения или секрет-менеджер.

**Хороший пример:**
```go
type Config struct {
    JWTKey string `env:"JWT_KEY,required"`
}
```

---

### 5.2. Хеширование паролей
Ещё одна частая ошибка, когда пароли пользователей хранятся в базе данных в открытом виде. Это может приводить к компрометации и репутационным рискам.

**Как правильно**  
Стоит хранить bcrypt-хеши.

---

## 6. Баги в бизнес-логике

### 6.1. Накрутка монет
В некоторых проектах пользователь может отправить монеты сам себе: такие лазейки обычно приводят к накруткам баланса и фроду.

**Как правильно**  
Стоит добавлять валидацию `from user != to user`.

**Хороший пример:**
```go
if fromUserID == toUserID { return ErrSelfTransfer }
```

---

### 6.2. Неатомарные операции
В некоторых проектах баланс может меняться без транзакции.

**Как правильно**  
Стоит оборачивать бизнес-операции в транзакции базы данных. Для этого нужно использовать transaction-manager.

**Хороший пример:**
```go
err := trManager.Do(ctx, func(ctx context.Context) error {
    balance, err := GetBalance(ctx, fromUser)
    if err != nil {
        return err
    }

    if balance < amount {
        return ErrInsufficientFunds
    }

    if err := AddBalance(ctx, fromUser, -amount); err != nil {
        return err
    }

    if err := AddBalance(ctx, toUser, amount); err != nil {
        return err
    }

    return nil
})
```

---

### 6.3. Сравнивание ошибок
Бывает, ошибки сопоставляются через `==` или `strings.Contains()`. В таком случае растёт риск пропустить специфичную ошибку — а проверить обёрнутую ошибку и вовсе становится невозможно.

**Как правильно**  
Стоит использовать `errors.Is()`.

**Хороший пример:**
```go
if errors.Is(err, ErrInsufficientFunds) { /* ... */ }
```

---

## 7. Технический долг

### 7.1. `TODO` без привязки к задаче
Оставлять комментарии-заглушки без номера тикета и срока — это моветон. Так статус кода становится неясным, копятся долги.

**Как правильно**  
Стоит переносить todo в issue-трекер, а в коде ссылаться на задачу.

**Хороший пример:**
```go
// TODO (TASK-123): Заменить поход в БД на кэш к 01.01.26.
```
