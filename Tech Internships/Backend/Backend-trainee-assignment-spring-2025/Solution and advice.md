# Стажировки для Backend-разработчиков в Авито: на что мы смотрим при проверке работ

Наши эксперты проанализировали тестовые задания кандидатов прошедшего отбора и рассказали о том, какие ошибки встречались чаще всего.  
Все совпадения случайны!

---

## Валидация бизнес-правил

Во многих проектах бизнес-правила — например, допустимые города или типы товаров — проверялись только на уровне базы данных.  

**Пример:**

```sql
city VARCHAR(100) NOT NULL
   CHECK (city IN ('Москва', 'Санкт-Петербург', 'Казань')),
type VARCHAR(50) NOT NULL
   CHECK (type IN ('electronics', 'clothing', 'shoes')),
status VARCHAR(20) NOT NULL
   CHECK (status IN ('in_progress', 'closed'))
   DEFAULT 'in_progress'
```
На первый взгляд кажется, что решение простое и надёжное: база не позволит записать некорректные данные. Однако на практике это создаёт больше проблем, чем пользы.

---

### Почему так не стоит делать

1. **Нарушается принцип разделения ответственности**  
   Бизнес-правила — это часть прикладной логики, а не уровня хранения данных. Когда их вшивают в схему, валидация расползается между слоями.

2. **Становится неудобно сопровождать базу данных**  
   Чтобы изменить бизнес-правила, приходится создавать миграции, перекатывать схему, пересоздавать constraint. Особенно сложно, когда бизнес-правила часто меняются — к примеру, добавляется много новых городов или типов товаров.

3. **Некорректно обрабатываются ошибки**  

**Какая ошибка должна быть:**  
```json
{"error": "город 'Томск' недоступен для открытия ПВЗ"}
```

**Какой она будет, если вшить бизнес-правила в базу данных:**  
```
pq: new row for relation "pvz" violates check constraint "allowed_city"
```

Обработку ошибок можно исправить дублированием логики в приложении — но в таком случае теряется единый источник истины и повышается риск расхождений.

4. **Такой код сложнее тестировать**  
   Если валидация проведена только на уровне базы данных, её невозможно проверить в отрыве от инфраструктуры.

5. **Базу данных становится сложно переносить**  
   СУБД по-разному реализуют ограничения, а в некоторых их и вовсе может не быть.

---

### Как тогда делать

Рекомендуем проводить валидацию на уровне приложения. База данных должна обеспечивать только целостность — например, `NOT NULL` и внешние ключи.  

В редких случаях в базе может быть дополнительная защита — но только если вы уверены, что список будет меняться редко. Даже тогда это не должно быть единственным местом проверки.

---

## Хранение данных

В некоторых проектах поля `city`, `type` и `status` хранились как `VARCHAR` или `TEXT`. На первый взгляд кажется, что это просто и удобно, но у такого подхода есть серьёзные недостатки.

---

### Почему так не стоит делать

1. **Становится сложно вносить изменения**  
   Если понадобится переименовать значение — например, `"clothing"` в `"clothing/t-shirt"` — придётся обновлять все записи в таблице. Это долго, ресурсоёмко и повышает риск рассинхронизации.

2. **Снижается эффективность кода**  
   Строки занимают больше места, чем числовые идентификаторы. Операции сравнения строк выполняются медленнее, чем сравнение чисел, особенно на больших объёмах данных.

3. **Появляются трудности в индексации и агрегации**  
   Индексы по строковым полям больше по размеру и работают медленнее. Это снижает производительность фильтрации, сортировки и агрегирующих запросов.

---

## Почему не стоит полагаться на ENUM

Другой распространённый вариант — использовать `ENUM` вместо строк. У такого подхода есть плюсы, но и существенные минусы.

1. **Чтобы изменить или удалить значение, придётся перестраивать всю таблицу.**  
   Если таблица большая, это приводит к блокировкам и простоям.

2. **Ограничивается гибкость.**  
   При добавлении новых значений приходится постоянно обновлять миграции.

---

### Как тогда делать

Рекомендуем провести нормализацию данных. Самое устойчивое решение — вынести справочники (`city`, `type`, `status`) в отдельные таблицы:  

- Таблица **cities** (`id`, `name`)  
- Таблица **product_types** (`id`, `name`)  
- Таблица **statuses** (`id`, `name`)  

А в основной таблице хранить только целочисленные ключи: `city_id`, `type_id`, `status_id`.

**Плюсы подхода:**  
- Быстрое хранение и сравнение.  
- Возможность централизованно менять значения.  
- Удобство индексации и агрегации.  
- Гибкость структуры.  

---

## Работа с индексами

Во многих решениях кандидаты не добавляли индексы к таблицам. На тестовых данных это может быть незаметно, но в реальной системе быстро приводит к проблемам.

---

### Почему так не стоит делать

1. **Снижается производительность запросов.**  
   При фильтрации или `JOIN` без индексов база сканирует всю таблицу.  

2. **Усложняется масштабирование.**  
   При росте объёма данных запросы начинают выполняться значительно дольше.

---

### Как тогда делать

В таблицах важно добавлять индексы для:  
- Полей, используемых в фильтрах (`WHERE city_id = ? AND date BETWEEN …`),  
- Внешних ключей и связей между таблицами,  
- Полей сортировки и пагинации (`ORDER BY created_at, id`).  

Для сложных фильтров — используйте составные индексы, например `(pvz_id, date)`.

⚠️ **Важно:** избыточные индексы замедляют записи (`INSERT`, `UPDATE`, `DELETE`) и занимают место. Добавляйте их только после анализа `EXPLAIN ANALYZE`.

---

## Тестирование кода

Во многих работах код не был протестирован. Часто кандидаты покрывают тестами инфраструктурные части, но не бизнес-логику.

---

### Как делать не надо

```go
func TestGetUserRepository(t *testing.T) {
   repo := NewUserRepo(mockDB)
   _, err := repo.GetByID(42)
   require.NoError(t, err)
}
```

---

### Почему так не стоит делать

1. **Создаётся ложное чувство защищённости.**  
   Такие тесты не ловят ошибки в логике.  

2. **Смещается фокус внимания.**  
   Проверяются детали реализации, а не сценарии.  

3. **Повышаются трудозатраты.**  
   Инфраструктурные тесты часто ломаются при рефакторинге.  

---

### Как тогда делать

Сосредоточьтесь на тестировании бизнес-логики:  
- Переходы состояний (например, статусы заказов).  
- Расчёты скидок и комиссий.  
- Обработку ошибок и граничных условий.  

---

## «Толщина» интерфейса

Иногда встречаются интерфейсы, объединяющие слишком много сущностей.  

---

### Как делать не надо

```go
type Repository interface {
    CreateUser(...)
    GetUserByEmail(...)
    CreatePVZ(...)
    GetReceptionByID(...)
    CreateProduct(...)
}
```

---

### Как тогда делать

Разделяйте интерфейсы по доменам — `UserRepository`, `PVZRepository`, `ProductRepository`.  
Это повышает читаемость, тестопригодность и гибкость архитектуры.

---

## Собранность бизнес-логики

Бизнес-логика должна быть сосредоточена в одном сервисном слое. Когда проверки и бизнес-правила размазаны по обработчикам, репозиториям и вспомогательным функциям — код становится нечитабельным.

---

### Как тогда делать

- Бизнес-правила — в сервисах.  
- Репозитории — только за доступ к данным.  
- Handlers — только за приём и отдачу запросов.

---

## Лаконичность в транзакциях

Не стоит оборачивать каждую операцию в транзакцию.  

---

### Как делать не надо

```go
func (r *PostgresRepo) GetLastOrder(ctx context.Context, warehouseID int) (*Order, error) {
   var order Order
   err := r.withTx(ctx, func(tx *sqlx.Tx) error {
       return tx.QueryRowContext(
           ctx,
           `SELECT id, status FROM orders WHERE warehouse_id = $1 ORDER BY created_at DESC LIMIT 1`,
           warehouseID,
       ).Scan(&order.ID, &order.Status)
   })
   if err != nil {
       return nil, fmt.Errorf("failed to get last order: %w", err)
   }
   return &order, nil
}
```

---

### Как тогда делать

Используйте транзакции только там, где нужно сохранить атомарность нескольких изменений. Решение о применении транзакции должно приниматься на уровне бизнес-логики.

---

## Работа с конфигурацией

Нельзя хранить чувствительные данные в коде.

---

### Как делать не надо

```go
sql.Open("postgres", "postgres://user:password@localhost:5432/master")
```

---

### Как тогда делать

Используйте переменные окружения:

```go
sql.Open("postgres", os.Getenv("DB_CONN"))
```

**Примеры:**  
- `export DB_CONN="postgres://user:password@localhost:5432/master"`  
- `.env` файл  
- Docker/Kubernetes параметры  
- Vault или другое хранилище секретов

---

## Настройка линтеров

Несоблюдение форматирования и правил стиля снижает читаемость и качество кода.

---

### Как делать не надо

```go
func add(a int, b int) int {
   return a+b
}
```

**При запуске линтера:**  
```
gofmt: File is not formatted with gofmt
```

---

### Как тогда делать

Настройте линтеры и автоформатирование (например, `pre-commit hook`).  
Регулярно обновляйте конфигурацию линтеров.

---

## Логирование в приложении

Ошибки нужно логировать, а не игнорировать.

---

### Как делать не надо

```go
func handleRequest(w http.ResponseWriter, r *http.Request) {
   if _, err := db.Query("INSERT INTO users(name) VALUES('test')"); err != nil {
       w.WriteHeader(http.StatusBadRequest)
   } else {
       w.WriteHeader(http.StatusOK)
   }
}
```

---

### Как тогда делать

Используйте логирование (например, Zap или Slog).  
Не логируйте чувствительные данные (пароли, токены).

---

