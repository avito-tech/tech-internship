# Стажировки для Frontend-разработчиков в Авито: на что мы смотрим при проверке работ

Разработчики Авито проанализировали тестовые задания кандидатов и выделили самые распространённые ошибки. Делимся их разбором — с моментами, на которые стоит обратить особое внимание.

### Общие рекомендации

#### Архитектура проекта
Прежде чем начинать реализацию решения задания, стоит задуматься над его архитектурой и выбрать самую подходящую для заданного случая. Возьмите относительно несложную и привычную вам архитектуру и потратьте время на реализацию дополнительных технических фич, это будет полезнее, чем разбираться, какие файлы в какие папки нужно складывать.
Для реализации клона Авито рекомендуется использовать структуру вида:
```
src/
 | api/ (обращение к серверу)
 | components (общие ui-компоненты)
 | helpers (функции-помощники, которые можно переиспользовать, либо же они слишком громоздкие, чтобы оставлять их в основном коде)
 | assets/icons (статика)
 | pages/ (страницы для роутинга)
 | types/ (типы проекта)
```

#### Управление состоянием
Для управления состоянием (например, списком объявлений, данными формы) на начальном этапе используйте встроенные средства фреймворка (React `useState`, `useReducer`, Context API). Не усложняйте архитектуру подключением Redux/MobX без явной необходимости — это может занять много времени, которое лучше потратить на реализацию основной логики и дополнительных фич.
#### История коммитов
Однозначно будет плюсом чистая история коммитов вида «одна подзадача — один коммит». Это продемонстрирует проверяющим, что вы думаете не только над самим проектом, но и над историей его изменений.

#### Юнит-тесты
Покрытие своего кода юнит-тестами — это хороший тон. При реализации тестов важно продумать все корнер-кейсы, а также специально что-то «поломать в них» (например, если функция складывает числа и получает `a=1, b=2`, то на время отладки поставить `.toBe(1)`, чтобы убедиться в правильности и валидности тестов).
Мокайте внешние зависимости, такие как localStorage или обращение к API.

#### UI/UX
Схематично продумайте макет своего решения в Figma или на листе бумаги. Это поможет избежать заторов во время вёрстки и сконцентрироваться на написании кода.

#### Разделение кода
Разделяйте код на секции. Например, в React-компоненте сначала получаем данные, затем обрабатываем их, а уже потом отрисовываем. Не стоит их перемешивать.
Стоит также разбивать громоздкий компонент на подкомпоненты, особенно, если это логически обосновано. Это позволит освободить вас от необходимости держать большой объём информации в голове.

#### Нейминг
Давайте осмысленные названия как компонентам, так и функциям. Плохие названия заставляют гадать о предназначении кода, хорошие — документируют его. Например, используйте `handleInputChange` вместо `onChange`, `SubmitButton` вместо `Button1`, `ListingCard` вместо `CardComponent`.

#### Настройте Prettier и ESLint
На реализацию задания отводится ограниченное количество времени, которого зачастую не хватает. Позвольте себе думать над технической реализацией, а не над кодстайлом. Это не убережет вас от, например, отделения логики от ui, но даст возможность не расставлять табуляцию и точки с запятой.

#### Соответствие требованиям
При разработке всегда сверяйтесь с техническими требованиями и уточняйте непонятные моменты.

### Советы технической реализации
#### Общие рекомендации
- Выбирайте TypeScript. Это золотой стандарт в разработке, который упрощает как написание кода, так и его поддержку в дальнейшем. Помимо всего прочего, это устраняет необходимость отлавливать большинство багов в рантайме.
  
- Выберите одну из современных UI-библиотек и используйте её при разработке. Это не только продемонстрирует умение пользоваться UI-библиотеками (в больших проектах, зачастую, есть дизайн системы и нужно пользоваться только ими), но и позволит уделить больше внимания логической части задания, а не вёрстке.
  
- Можно сразу разрабатывать приложение в docker-контейнерах. На начальном этапе гораздо проще всё настроить и не волноваться после, пытаясь запустить проект в контейнерах, когда он уже написан.

#### Роутинг
В `App.tsx` оставьте логику роутинга.
```tsx
<BrowserRouter>
    <Routes>
      <Route path="/form" element={<FormPage />} />
      <Route path="/list" element={<ListPage />} />
      <Route path="/item/:id" element={<ItemPage />} />
    </Routes>
</BrowserRouter>,
```
На страницах же реализуйте основную логику работы приложения. Для страницы товара используется `useParams()`, чтобы получить `id` объявления и затем обратиться к БД.

#### Многошаговая форма
- валидация всех полей через `zod`;
- сохранение в черновик через `localStorage`.

Благодаря выбору типа объявления на первом этапе формы, можно условно отрисовывать второй шаг формы.
В одной и той же форме можно как создавать новое объявление, так и редактировать старое. Для редактирования нужно просто проставить начальные данные, полученные по `id` из url.
Использование валидации (например, zod) является важным моментом. В реальных проектах обязательно используется валидация, и это позволит не только защитить свою форму от нежелательных данных, которые могут сломать дальнейшую работу, но и ускорит разработку, так как IDE будет иметь представление о типе формы. Помимо всего прочего, при неправильном типе или формате данных пользователь получит человекочитаемую ошибку, а не системную.
Промежуточное сохранение черновиков лучше всего реализовать через сохранение в `localStorage`. Для этого можно реализовать хук `useThrottle`, который сохраняет данные не на каждый `onChange`, а через одинаковые промежутки времени, если в форму что-то вводится.

#### Унификация данных через `Listing` и `transformListings`
Бэкенд в этом задании отдаёт разные типы объявлений (авто, недвижимость, услуги) с разными наборами полей. Это является проблемой при отображении списка всех объявлений. Чтобы не протаскивать эту разницу через все компоненты, удобно ввести единый тип для отображения `Listing` и функцию‑адаптер `transformListings`.

`Listing` описывает ровно то, что нужно для UI:
- `id` — идентификатор объявления;
- `type` — категория (Недвижимость, Авто, Услуги);
- `title`, `description`, `location` — базовые поля, приводимые из `name` и т.п.;
- `price: number | null` — цена, если есть;
- `imageSrc` — ссылка на изображение или заглушку под категорию;
- `details: string[]` — массив строк с основными характеристиками (тип недвижимости, площадь, марка авто, опыт и т.д.).

Функция `transformListings` принимает массив «сырых» сущностей с бэка и по характерным полям (`brand`, `propertyType`, `serviceType`) определяет тип объявления. В зависимости от этого она собирает `Listing`: проставляет правильную заглушку `imageSrc` и наполняет `details` человекочитаемыми строками. В результате все страницы (`/list`, `/item/:id`) работают с единым типом `Listing` и не зависят напрямую от структуры API.

#### Поиск и фильтрация на странице списка
`Listing` также полезен при поиске и фильтрации объявлений на `/list`. Он строится поверх унифицированного массива и разбит на несколько независимых критериев:
- **Поиск по названию.**
  Фильтр: `ad.title.toLowerCase().includes(searchTerm.toLowerCase())`.
- **Фильтрация по категории.**
   Если выбран конкретный тип, оставляются только объявления с `ad.type === searchType`, иначе фильтр по типу не применяется.
- **Дополнительный поиск по деталям.**
  При наличии `detailedSearchTerm` берётся массив `details`, склеивается в одну строку (`details.join(' ')`), приводится к нижнему регистру и проверяется на вхождение подстроки.

#### Пагинация
Добавить клиентскую пагинацию поверх уже готового фильтра можно без серьёзных изменений:
- Ввести состояние для текущей страницы и размер страницы:
```tsx
const [page, setPage] = useState(1);
const pageSize = 5;
```
- После получения `filteredAds` вычислять срез для текущей страницы:
```tsx
const start = (page - 1) * pageSize;
const paginatedAds = filteredAds.slice(start, start + pageSize);
```
- В компонент списка передавать `paginatedAds` вместо `filteredAds` и добавить элемент управления пагинацией (кнопки «Назад/Вперёд» и номера страниц), который будет вызывать `setPage`.
