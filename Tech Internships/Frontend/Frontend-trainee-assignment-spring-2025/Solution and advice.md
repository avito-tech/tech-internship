# Стажировки для Frontend-разработчиков в Авито: на что мы смотрим при проверке работ

Разработчики Авито проанализировали тестовые задания кандидатов и выделили самые распространённые ошибки. Делимся их разбором — с моментами, на которые стоит обратить особое внимание.

---

## Сверка с техническим заданием

Перед отправкой результатов **перепроверьте, что реализовали все функции**, описанные в техническом задании.

> **Пример:** Если указано, что URL страницы доски должен быть `/board/{id}`, не стоит его менять — иначе есть риск навредить проекту (правила nginx, SEO-оптимизация).

## Проверка на сайте

Всегда полезно в целом перепроверить код, который вы написали. Но смотреть на фичи важно **не только в коде, но и на самом сайте**. Иногда даже самые простые функции не работают.

## Оформление README

Если вы добавите `README`, проверяющему будет проще погрузиться в ваш проект. Цель — дать **чёткие инструкции по запуску**, включая Docker, объяснить архитектуру, обосновать выбор технологий.

Чтобы файл было удобнее читать, **используйте Markdown**: оформите заголовки, списки, код. Лучше писать **кратко, но информативно**, с конкретикой и без общих фраз. Укажите, как код отвечает требованиям: перечислите проблемы, **компромиссы**, на которые пошли, возможные улучшения.

### Рекомендации разделов в README

1.  Описание проекта.
2.  Запуск проекта.
3.  Стек технологий.
4.  Архитектура.
5.  Особенности реализации.

## Юнит-тесты

Не забывайте их писать: юнит-тесты делают код надёжнее и снижают риск ошибок в проде, проверяют логику и корректную работу критических частей приложения.

### Рекомендации

* **Для утилит:** проверяйте корнер-кейсы: пустые данные, ошибки парсинга.
* **Для компонентов:** тестируйте рендеринг и взаимодействие с UI.
* **Для store:** тестируйте редьюсеры и селекторы отдельно, проверяйте начальное состояние и изменения.
* **Мокайте зависимости** (`localStorage`, API, Redux) для изоляции.

## Комментарии в коде для сложной логики

Если чувствуете, что у кода **сложная логика**, оставляйте **комментарии** для проверяющего. Это поможет понять ваш подход.

### Рекомендации

* Добавляйте **инлайн-комментарии** для неочевидных решений.
* **Объясняйте, почему** решили сделать так, а не иначе: *например, можно оставить комментарий «Отмена запросов предотвращает race conditions»*.
* Избегайте тривиальных комментариев — например, «Цикл for».
* Пишите **лаконично, но информативно**.

## Осмысленные названия

Давайте **понятные и значимые названия** всем компонентам, переменным, функциям, хукам и прочим конструкциям.

> **Плохой пример:** `Popup`
>
> **Хороший пример:** `TaskFormPopup` (сразу понятно, за что отвечает компонент).

## Выбор и фиксация архитектуры

Это делает код более **масштабируемым, поддерживаемым и читаемым**.

### Рекомендации

* **Выберите подходящую архитектуру,** которой будете следовать.
* **Аргументируйте выбор** — например, через сравнительную таблицу.
* **Зафиксируйте документацию** по архитектуре в `README` или `ARCHITECTURE.md`: структура папок, принципы, диаграммы.
* Обоснуйте компромиссы.

## Error Boundary

Этот компонент в React помогает обрабатывать ошибки, **предотвращает краш всего приложения** и улучшает UX.

### Рекомендации

* Реализуйте **один компонент Error Boundary** и переиспользуйте его, передавая разные `fallback` через `props`.
* **Логируйте ошибки** в `componentDidCatch` для отладки.
* **Тестируйте Error Boundary**: проверьте рендеринг `fallback` при ошибке.
* **Избегайте избыточности.** Оборачивайте не каждый компонент, а только критичные узлы: страницы, формы.

## Виртуализация списка

Используйте её, чтобы **оптимизировать производительность** при рендеринге **больших списков**. Рендерятся только видимые элементы, снижая нагрузку на DOM и улучшая UX.

### Рекомендации

* Применяйте виртуализацию **только для больших списков** (где много задач).
* **Тестируйте производительность:** проверьте плавность скроллинга с большим списком (например, из 1 000 задач).
* Избегайте избыточной виртуализации: **не используйте её для списков, где меньше 50 элементов.**

## Организация экспортов

Правильная организация экспортов **упрощает импорт модулей**, улучшает читаемость и поддерживаемость кода.

### Рекомендации

* Используйте **named exports** (`export const`) для утилит и хуков.
* Создавайте **баррели (`index.ts`)**: в папках (`src/components`, `src/hooks`), создавайте `index.ts` для реэкспорта всех модулей.
    * *Пример: `import { IssueForm, Header } from './components'`.*
* **Не создавайте баррели** для глубоко вложенных папок или одиночных модулей.
* **Проверяйте импорты.** Убедитесь, что баррели не создают **циклических зависимостей**, используйте ESLint `import/no-cycle`.

## Организация и сортировка импортов

С ней ваш код станет **более чистым и консистентным**: его будет проще читать, улучшится навигация.

### Рекомендации

* Используйте **ESLint для сортировки**: настройте плагин `eslint-plugin-import` с правилом `import/order`.
* **Группируйте импорты:**
    * Встроенные модули (`react`, `react-router-dom`).
    * Внешние библиотеки (`@mui/material`, `@reduxjs/toolkit`).
    * Внутренние модули (`@/components`).
    * Локальные файлы (`./IssueForm`, `../utils`).
* **Структурируйте группы:** разделяйте группы пустыми строками.
* Для предсказуемости **сортируйте импорты в каждой группе по алфавиту**.
* **Избегайте смешанных импортов.** Разделяйте `import type` от обычных импортов, помещайте их в начало.

## Разделение функциональных компонентов

Если функциональные компоненты слишком большие (обычно **более 150 строк**), их становится сложно читать, поддерживать и тестировать. **Такие компоненты нужно разделять.**

### Рекомендации

* Выносите **константы** с учётом области использования:
    * Создавайте отдельный файл рядом с компонентом (`constants.ts`) для локальных констант.
    * Общие константы выносите в глобальную папку (`src/constants`).
    * **Не выносите нединамический текст** в константы (если нет i18n).
* Переносите **сложную или переиспользуемую логику в кастомные хуки**.
* Выносите **чистые функции**, используемые в нескольких местах, в `src/utils`.
* **Разделяйте UI и логику:** оставляйте в компоненте только рендеринг и обработку событий, перенося бизнес-логику в хуки или утилиты.

## Стили в JSX

Лучше **не прописывать стили через `style={}`** — это делает разметку громоздкой и создает высший приоритет. При этом иногда решение оправдано (например, для библиотечных наборов цветов, объявленных через JS/TS).

## Перфоманс и Core Web Vitals

Сайт должен **быстро загружаться**. Перфоманс-метрики влияют на ранжирование в поисковых системах.

> В оценке скорости загрузки страницы можно опираться на стандарт **Core Web Vitals** (шесть метрик от Google).

## Сторонние библиотеки

**Не бойтесь использовать библиотеки** с готовым кодом: они могут упростить и ускорить разработку. Но **не увлекайтесь ими слишком сильно**: иначе будет сложно понять, как устроен проект.

## Работа с условными операторами

Старайтесь не допускать ситуаций, когда сравнение содержит **больше 2-3 операндов** или же эти операнды слишком длинные.

> **Плохой пример:**
>
> `if (user.name && user.surname && form.title && form.mode === 'edit') { return; }`
>
> **Хороший пример (выделение в логические группы):**
>
> ```javascript
> const userPresence = user.name && user.surname;
> const formModeIsEdit = form.mode === 'edit'
>
> if (userPresence && form.title && formModeIsEdit) { return; }
> ```

## Логирование

Следите за тем, чтобы приложение **не выбрасывало в консоль лишние логи**: они могут содержать **чувствительные приватные данные**.

## Запросы к серверу

Приложение не должно отправлять **лишних запросов на API-сервер**. Это может повлиять на консистентность данных и создать лишнюю нагрузку.

* Чтобы избежать отправки запросов (например, при нескольких нажатиях на кнопку), используйте **`debounce`** или **блокируйте кнопку**.
* Проверяйте вкладку **Network** в инструментах отладки, чтобы не запрашивались неиспользуемые данные.

## Переменные окружения

При деплое в приложение можно добавлять данные, которые будут лежать в окружении. Удобно для приложений, развёрнутых в контейнере.

> **Пример:** хранение адреса API-сервера: `API_URL="https://kek.cheburek"`

## Маппинг данных

Используйте его, чтобы **не создавать много лишних условных операторов** для выбора нужного варианта.

> **Хороший пример** (для состояний формы: просмотр, редактирование, создание):
>
> ```typescript
> enum TaskFormAim {
>    View = 'view',
>    Edit = 'edit',
>    Create = 'create',
> }
>
> const taskFormNameMapping: Record<TaskFormAim, string> = {
>    [TaskFormAim.View]: 'Просмотр задачи',
>    [TaskFormAim.Edit]: 'Редактирование задачи',
>    [TaskFormAim.Create]: 'Создание задачи',
> }
> ```

## Запрос данных из API

Старайтесь **избегать последовательных запросов, если это возможно**. Они увеличивают время ожидания пользователем целевого действия на сайте (или время первой отрисовки). Человек может не дождаться, пока на странице что-то появится, и уйти с неё. 
