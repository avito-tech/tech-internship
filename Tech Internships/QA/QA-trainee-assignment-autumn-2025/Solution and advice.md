# Разбор тестового задания на стажировку для QA-инженеров в Авито (осенний отбор 2025)
Тестовое состояло из двух заданий. В первом задании мы предлагали найти баги и определить их приоритеты на карьерном сайте Авито. Во втором задании мы предлагали написать автотесты: API или UI.
## Задание 1. Поиск багов.

Как и при реальной работе, нам важно, чтобы кандидат минимизировал потенциальный ущерб продукту/компании, поэтому высоко ценились работы, в которых были найдены баги с высоким приоритетом.
Так, в данном задании следовало обратить внимание на валидность поисковой выдачи.

Вот на что еще мы обращали внимание при проверке этого задания:

1. Количество найденных багов.
При этом их не так много, чтобы было просто внести в решение мелкие недочеты и улучшения. Небольшие замеченные моменты, не заложенные в само задание, могли пойти плюсом к оценке, но не оказывали существенного влияния на финальную оценку.

2. Описание багов.
Важно чтобы кандидаты умели правильно и четко описывать баги, чтобы было понятно, что кандидат имел в виду. При этом хорошо, если описание не избыточное.

3. Точность определения приоритета багов.
Это важный аспект при работе с багами как в тестовых заданиях, так и при разработке.

Отдельный плюс ставили за аргументацию выставления приоритетов, а также за приложения в оформления багов.
## Задание 2. Написание автотестов.

В работе QA-инженера в Авито часто приходится писать автотесты, и, зачастую, это UI и API-тесты. Поэтому во 2-м задании мы предложили кандидатам выполнить задание на написание либо UI, либо API-тестов.

Несмотря на разные уровни тестов, проект оценивался по ряду общих признаков:

1. Выбор сценариев для автоматизации и их грамотное описание в виде тест-кейсов.

Перед написанием автотестов нужно понять, что автоматизировать, а по итогам - составить список тест-кейсов. Оценивание зачастую начинается с просмотра составленных кандидатом тест-кейсов: учтены ли важнейшие сценарии, как они оформлены и прочее.

Без понимания того, что мы автоматизируем и зачем, проводить автоматизацию не имеет смысла.

Ориентируемся на применимые поля тест-кейсов.

2. Структура проекта

Структура проекта, логика директорий и наименований файлов — это всё часть культуры работы с кодом.
Если взять самые красивые, понятные и стабильные автотесты и сложить их в папку «new folder» с именами test_1, test_2 — сразу теряется прозрачность и понятность.

Пример плохой структуры (ее отсутствие):
![](https://github.com/avito-tech/tech-internship/blob/main/Tech%20Internships/QA/QA-trainee-assignment-autumn-2025/imgs/nostrukt.png)

Примеры хорошей структуры:
![](https://github.com/avito-tech/tech-internship/blob/main/Tech%20Internships/QA/QA-trainee-assignment-autumn-2025/imgs/strukt1.png)
![](https://github.com/avito-tech/tech-internship/blob/main/Tech%20Internships/QA/QA-trainee-assignment-autumn-2025/imgs/strukt2.png)

3. Инструкция

Инструкция. Чем проще, тем лучше: склонировать, установить зависимости, запустить.
Примеры:

Хороший пример:

Склонируйте к себе репозиторий, в котором хранится проект тестового задания, через выполнение команды в терминале

```
git clone https://github.com/avito-tech/tech-internship.git
```
Или скачайте zip-архив по ссылке и распакуйте его

Убедитесь, что на вашем компьютере установлен Python (или другой язык). В командной строке/терминале выполните команду

```
python -v  
```
Если он не установлен, то установите с официального сайта Python, выбрав подходящую версию для вашей операционной системы, и пройдите шаг сначала. В процессе установки обязательно поставьте галочку в чекбоксе "Add python.exe to PATH".

Через командную строку/терминал перейдите в корневую директорию проекта, выполнив команду

```
cd /здесь укажите путь до директории с проектом  
```
Установите необходимые зависимости из файла requirements.txt, выполнив команду

```
pip install -r requirements.txt
```
если она не выполняется, то попробуйте

```
pip3 install -r requirements.txt  
```
После выполнения предыдущего пункта установите необходимые бинарные файлы браузеров, выполнив команду

```
playwright install  
```
Наконец, запустите тесты, выполнив команду

```
pytest -v  
```

Плохой пример:
![](https://github.com/avito-tech/tech-internship/blob/main/Tech%20Internships/QA/QA-trainee-assignment-autumn-2025/imgs/bad.png)

Указана установка библиотеки requests, но в проекте были использованы и другие зависимости. Следовало указать все необходимые зависимости в отдельном файле (даже если зависимость только одна) и дать инструкции по их установке, например: pip install -r requirements.txt  


Антипаттерн: вслепую использовать инструкцию, составленную AI. Было много работ с идентичными инструкциями, и у части кандидатов тесты по ним не запускались.

4. Реализованы ли автотесты на описанные пользовательские сценарии

Все просто: описали тест-кейсы - реализовали автотесты. Тесты реально работают и ловят баги.

5. Как реализованы автотесты и код вообще.

Обращали внимание как на общее оформление, так и на детали. Важно, чтобы автотесты имели структуру, отвечали признакам хорошего автотеста, общий код выносился, применялись паттерны, подходящие для написания автотестов и значительно упрощающие работу с ними (например, PageObject).

Код должен быть читаемым (в том числе обращали внимание на именования), отвечать принципам DRY и KISS.

Часть реализации паттерна PageObject:

```
class BasePage:

    def __init__(self, driver):  
        self.driver = driver  
        self.base_url = "https://makarovartem.github.io/frontend-avito-tech-test-assignment/"

    def find_element(self, locator, time=10):  
        return WebDriverWait(self.driver, time).until(EC.presence_of_element_located(locator))

    def find_clickable_element(self, locator, time=15):  
        return WebDriverWait(self.driver, time).until(EC.element_to_be_clickable(locator))

    def find_game_cards(self, locator):  
        return self.driver.find_elements(*locator)

    def go_to_site(self):  
        return self.driver.get(self.base_url)

    def scroll_to_smth(self, element):  
        return self.driver.execute_script("arguments[0].scrollIntoView(true);", element)  
```
В базовый класс вынесены методы, которые будут использоваться на других страницах.
Это позволит уменьшить дублирование кода, упростит его поддержку.

Выносим отдельно общие элементы, логику и описания, например, вынос модели:

```
package com.avito.model;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class Item {
    private String id;

    private Integer sellerId;

    private String name;
    private Integer price;
    private Statistics statistics;
    private String createdAt;
}
```
6. Найдены и оформлены баги на функционал

Смотрели на то, поймали ли автотесты допущенные баги и на то, как оформлены баг-репорты.
Ориентируемся на применимые поля баг-репорта, чёткую структуру и понятность.

Пример:
![](https://github.com/avito-tech/tech-internship/blob/main/Tech%20Internships/QA/QA-trainee-assignment-autumn-2025/imgs/bugex.png)

7. Работа с Git

Обращали внимание на историю коммитов, их названия и описание, а также на чистоту репозитория

Пример:
![](https://github.com/avito-tech/tech-internship/blob/main/Tech%20Internships/QA/QA-trainee-assignment-autumn-2025/imgs/commitex.png)


